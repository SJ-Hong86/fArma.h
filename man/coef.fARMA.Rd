% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/armaExtractors.R
\name{coef.fARMA}
\alias{coef.fARMA}
\title{Integrated ARMA Time Series Modelling}
\usage{
armaSim(model = list(ar = c(0.5, -0.5), d = 0, ma = 0.1), n = 100,
        innov = NULL, n.start = 100, start.innov = NULL,
        rand.gen = rnorm, rseed = NULL, addControl = FALSE, ...)
armaFit(formula, data, method = c("mle", "ols"), include.mean = TRUE,
        fixed = NULL, title = NULL, description = NULL, ...)

# S4 method for signature 'fARMA'
show(object)

# S3 method for class 'fARMA'
fitted(object, ...)

# S3 method for class 'fARMA'
coef(object, ...)

# S3 method for class 'fARMA'
residuals(object, ...)
}
\arguments{
\item{object}{\link[=predict]{summary} -
is an object of class \code{fARMA} returned by the fitting function \code{armaFit} and
serves as input for the \code{summary}, and predict methods. Some methods
allow for additional arguments.}

\item{...}{additional arguments to be passed to the output timeSeries.}

\item{addControl}{\link{armaSim} -
a logical value. Should control parameters added to the returned series
as a control attribute?}

\item{data}{an optional timeSeries or data frame object containing
the variables in the model. If not found in data, the variables are taken from
\code{environment(formula)}, typically the environment from which \code{armaFit} is
called. If data is an univariate series, then the series is converted into a
numeric vector and the name of the response in the formula will be neglected.}

\item{description}{a character string which allows for a brief description.}

\item{doplot}{\link{armaRoots} -
a logical. Should a plot be displayed?
\link{predict} -
is used by the predict and \code{summary} methods. By default, this value is set
to \code{TRUE} and thus the function calls generate beside written also
graphical printout. Additional arguments required by underlying
functions have to be passed through the \code{dots} argument.}

\item{fixed}{\link{armaFit} -
is an optional numeric vector of the same length as the total number of
parameters. If supplied, only \code{NA} entries in \code{fixed} will be varied. In this
way subset ARMA processes can be modeled. ARIMA modelling
supports this option. Thus for estimating parameters of subset ARMA
and AR models the most easiest way is to specify them by the formulas
\code{x~ARIMA(p, 0, q)} and \code{x~ARIMA(p, 0, 0)}, respectively.}

\item{formula}{\link{armaFit} -
a formula specifying the general structure of the ARMA form. Can have
one of the forms \code{x ~ ar(q)}, \code{x ~ ma(p)}, \code{x ~ arma(p, q)},
\code{x ~ arima(p, d, q)}, or \code{x ~ arfima(p, q)}.
\code{x} is the response variable optionally to appear in the formula expression.
In the first case R's function \code{ar} from the ts package will be used
to estimate the parameters, in the second case R's function \code{arma} from
the \code{tseries} package will be used, in the third case R's function
\code{arima} from the ts package will be used, and in the last case R's function
\code{fracdiff} from the \code{fracdiff} package will be used. The state space modelling
based \code{arima} function allows also to fit ARMA models using \code{arima(p, d=0, q)},
and AR models using \code{arima(q, d=0, q=0)}, or pure MA models using \code{arima(q=0, d=0, p)}
(Exogenous variables are also allowed and can be passed through the \code{...} argument.).}

\item{gof.lag}{[print][plot][summary][predict] -
the maximum number of lags for a goodness-of-fit test.}

\item{include.mean}{\link{armaFit} -
Should the ARIMA model include a mean term? The default is \code{TRUE},
note that for differenced series a mean would not affect the fit nor predictions.}

\item{innov}{\link{armaSim} -
is a univariate time series or vector of innovations to produce the series.
If not provided, \code{innov} will be generated using the random number
generator specified by \code{rand.gen}. Missing values are not allowed.
By default the normal random number generator will be used.}

\item{method}{\link{armaFit} -
a character string denoting the method used to fit the model. The
default method for all models is the log-likelihood parameter estimation
approach, \code{method="mle"}. In the case of an AR model the parameter
estimation can also be done by ordinary least square estimation, \code{"ols"}.}

\item{model}{\link{armaSim} -
a list with one (AR), two (ARMA) or three (ARIMA, FRACDIFF) elements.
\code{ar} is a numeric vector giving the AR coefficients, \code{d} is an integer value
giving the degree of differencing, and \code{ma} is a numeric vector giving the
MA coefficients. Thus the order of the time series process is
(F)ARIMA(p, d, q) with \code{p=length(ar)} and \code{q=length(ma)}.
\code{d} is a positive integer for ARIMA models and a numeric value
for FRACDIFF models. By default an ARIMA(2, 0, 1) model with coefficients
\code{ar=c(0.5, -0.5)} and \code{ma=0.1} will be generated.}

\item{n}{\link{armaSim} -
an integer value setting the length of the series to be simulated
(optional if \code{innov} is provided). The default value is 100.}

\item{n.ahead}{[print][plot][summary][predict] -
are presetted arguments for the \code{predict} method. \code{n.ahead} determines
how far ahead forecasts should be evaluated together with errors on the
confidence intervals given by the argument \code{conf}. If a forecast plot is
desired, which is the default and expressed by \code{doplot=TRUE}, then
\code{n.back} sets the number of time steps back displayed in the graph.}

\item{n.back}{[print][plot][summary][predict] -
are presetted arguments for the \code{predict} method. \code{n.ahead} determines
how far ahead forecasts should be evaluated together with errors on the
confidence intervals given by the argument \code{conf}. If a forecast plot is
desired, which is the default and expressed by \code{doplot=TRUE}, then
\code{n.back} sets the number of time steps back displayed in the graph.}

\item{conf}{[print][plot][summary][predict] -
are presetted arguments for the \code{predict} method. \code{n.ahead} determines
how far ahead forecasts should be evaluated together with errors on the
confidence intervals given by the argument \code{conf}. If a forecast plot is
desired, which is the default and expressed by \code{doplot=TRUE}, then
\code{n.back} sets the number of time steps back displayed in the graph.}

\item{n.start}{\link{armaSim} -
gives the number of start-up values discarded when simulating non-stationary
models. The start-up innovations will be generated by \code{rand.gen}
if \code{start.innov} is not provided.}

\item{rand.gen}{\link{armaSim} -
is the function which is called to generate the innovations. Usually,
\code{rand.gen} will be a random number generator. Additional arguments
required by the random number generator \code{rand.gen}, usually the
location, scale and/or shape parameter of the underlying distribution
function, have to be passed through the \code{dots} argument.}

\item{rseed}{\link{armaSim} -
the random number seed, by default \code{NULL}. If this argument is set to an
integer value, then the function \code{set.seed(rseed)} will be called.}

\item{start.innov}{\link{armaSim} -
is a univariate time series or vector of innovations to be used as start up
values. Missing values are not allowed.}

\item{title}{a character string which allows for a project title.}

\item{which}{\link[=summary]{plot} -
if \code{which} is set to \code{"ask"} the function will interactively ask which plot
should be displayed. This is the default value for the \code{plot} method. If
\code{which="all"} is specified all plots will be displayed. This is the default
setting for the \code{summary} method. On the other hand, if a vector of
logicals is specified, then those plots will be displayed for which the
elements of the vector are set to \code{TRUE}.}

\item{x}{\link[=plot]{print} -
is an object of class \code{fARMA} returned by the fitting function \code{armaFit} and
serves as input for the \code{predict}, \code{print}, \code{print.summary}, and \code{plot} methods.
Some methods allow for additional arguments.}
}
\value{
\code{armaFit} returns an S4 object of class \code{"fARMA"},
with the following slots:

\code{call}	the matched function call.
\code{data} the input data in form of a data.frame.
\code{description} allows for a brief project description.
\code{fit} the results as a list returned from the underlying time series model function.
\code{method} the selected time series model naming the applied method.
\code{formula} the formula expression describing the model.
\code{parameters} named parameters or coefficients of the fitted model.
\code{title} a title string.
}
\description{
A collection and description of simple to use functions to model univariate
autoregressive moving average time series processes, including time series simulation,
parameter estimation, diagnostic analysis of the fit, and predictions of future values.

The Functions are:

\code{armaSim}	Simulates an artificial ARMA time series process.
\code{armaFit}	Fits the parameters of an ARMA time series process.
\code{print}	  Print Method.
\code{plot}   	Plot Method.
\code{summary}	Summary Method.
\code{predict}	Forecasts and optionally plots an ARMA process.
\code{fitted} 	Method, returns fitted values.
\code{coef}   	Method, returns coefficients.
\code{coefficients} 	Method, returns coefficients.
\code{residuals}Method, returns residuals.`
}
\details{
AR - Auto-Regressive Modelling:

The argument x~ar(p) calls the underlying functions ar.mle or ar.ols depending on
the method's choice. For definiteness, the AR models are defined through

$$x_t-\mu=a_1(x_{t-1}-\mu)+\cdots+a_p(x_{t-p}-\mu)+e_t$$

Order selection can be achieved through the comparison of AIC values for different
model specifications. However this may be problematic, as of the methods here only
\code{ar.mle} performs true maximum likelihood estimation. The AIC is computed as if the
variance estimate were the MLE, omitting the determinant term from the likelihood.
Note that this is not the same as the Gaussian likelihood evaluated at the estimated
parameter values. With \code{method="yw"} the variance matrix of the innovations is computed
from the fitted coefficients and the autocovariance of \code{x}. Burg's method allows for two
alternatives \code{method="burg1"} or \code{method="burg2"} to estimate the innovations variance and
hence AIC. Method 1 is to use the update given by the Levinson-Durbin recursion
(Brockwell and Davis, 1991), and follows S-PLUS. Method 2 is the mean of the sum of
squares of the forward and backward prediction errors (as in Brockwell and Davis, 1996).
Percival and Walden (1998) discuss both.

MA - Moving-Average Modelling:

The argument \code{x~ma(q)} maps the call to the argument \code{x ~ arima(0, 0, q)}.

ARMA - Auto-Regressive Moving-Average Modelling:

The argument \code{x~arma(p,q)} maps the call to the argument \code{x~arima(p, 0, q)}.

ARIMA - Integrated ARMA Modelling:

The argument \code{x~arima()} calls the underlying function \code{arima} from R's \code{ts} package.
For definiteness, the AR models are defined through

$$x_t=a_1x_{t-1}+\cdots+a_px_{t-p}+e_t+b_1e_{t-1}+\cdots+b_qe_{t-q}$$

and so the MA coefficients differ in sign from those of S-PLUS. Further,
if \code{include.mean} is \code{TRUE}, this formula applies to $x-m$ rather than $x$. For
ARIMA models with differencing, the differenced series follows a zero-mean ARMA model.
The variance matrix of the estimates is found from the Hessian of the log-likelihood,
and so may only be a rough guide.
Optimization is done by \code{optim}. It will work best if the columns in \code{xreg} are roughly
scaled to zero mean and unit variance, but does attempt to estimate suitable scalings.
The exact likelihood is computed via a state-space representation of the ARIMA
process, and the innovations and their variance found by a Kalman filter.
The initialization of the differenced ARMA process uses stationarity. For a differenced
process the non-stationary components are given a diffuse prior (controlled by \code{kappa}).
Observations which are still controlled by the diffuse prior (determined by having
a Kalman gain of at least 1e4) are excluded from the likelihood calculations.
(This gives comparable results to \code{arima0} in the absence of missing values, when
the observations excluded are precisely those dropped by the differencing.)
Missing values are allowed, and are handled exactly in method \code{"ML"}.
If \code{transform.pars} is true, the optimization is done using an alternative parametrization
which is a variation on that suggested by Jones (1980) and ensures that the model is
stationary. For an AR(p) model the parametrization is via the inverse tanh of the partial
autocorrelations: the same procedure is applied (separately) to the AR and seasonal AR
terms. The MA terms are not constrained to be invertible during optimization, but they
will be converted to invertible form after optimization if \code{transform.pars} is true.
Conditional sum-of-squares is provided mainly for expositional purposes. This computes
the sum of squares of the fitted innovations from observation \code{n.cond} on, (where \code{n.cond}
is at least the maximum lag of an AR term), treating all earlier innovations to be zero.
Argument \code{n.cond} can be used to allow comparability between different fits. The “part
log-likelihood” is the first term, half the log of the estimated mean square. Missing
values are allowed, but will cause many of the innovations to be missing.
When regressors are specified, they are orthogonalized prior to fitting unless any
of the coefficients is fixed. It can be helpful to roughly scale the regressors
to zero mean and unit variance.
Note from \code{arima}: The functions parse their arguments to the original time series
functions available in R's time series library \code{ts}.
The results are likely to be different from S-PLUS's \code{arima.mle}, which computes a
conditional likelihood and does not include a mean in the model. Further, the
convention used by \code{arima.mle} reverses the signs of the MA coefficients.

ARFIMA/FRACDIFF Modelling:

The argument \code{x~arfima()} calls the underlying functions from R's \code{fracdiff} package.
The estimator calculates the maximum likelihood estimators of the parameters of a
fractionally-differenced ARIMA (p,d,q) model, together (if possible) with their estimated
covariance and correlation matrices and standard errors, as well as the value of the
maximized likelihood. The likelihood is approximated using the fast and accurate
method of Haslett and Raftery (1989). Note, the number of AR and MA coefficients
should not be too large (say < 10) to avoid degeneracy in the model.
The optimization is carried out in two levels: an outer univariate unimodal optimization
in d over the interval \link{0,.5}, and an inner nonlinear least-squares optimization in the AR
and MA parameters to minimize white noise variance.
}
\examples{

# armaSim - Simulation
x = armaSim(model = list(ar = c(0.5, -0.5), ma = 0.1), n = 1000)

# armaFit - Estimate the Parameters
fit = armaFit(~ arma(2, 1), data = x)
print(fit)

# summary - Diagnostic Analysis
par(mfrow = c(2, 2), cex = 0.7)
summary(fit, which =  "all")

# predict - Forecast 5 Steps Ahead
par(mfrow = c(1, 1))
predict(fit, 5)

# armaFit - Alternative Calls
TS = MSFT
armaFit(formula = diff(log(Close)) ~ ar(5), data = TS)
armaFit(Close ~ ar(5), data = returns(TS, digits = 12))
TS.RET = returns(TS, digits = 12)
armaFit(Close ~ ar(5), TS.RET)
armaFit(Close ~ ar(5), as.data.frame(TS.RET))
armaFit(~ ar(5), as.vector(TS.RET[, "Close"]))
armaFit(~ ar(5), as.ts(TS.RET)[, "Close"])
attach(TS.RET)
armaFit(Close ~ ar(5))
detach(TS.RET)
}
